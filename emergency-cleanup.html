<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üö® NETTOYAGE D'URGENCE - Service Workers</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 30px;
            background: linear-gradient(135deg, #dc2626, #991b1b);
            color: white;
            text-align: center;
            border-radius: 20px;
        }
        .status {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 14px;
            text-align: left;
        }
        .btn {
            background: #059669;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            font-size: 16px;
        }
        .btn:hover { background: #047857; }
        .btn-danger { background: #dc2626; }
        .btn-danger:hover { background: #991b1b; }
    </style>
</head>
<body>
    <h1>üö® NETTOYAGE D'URGENCE</h1>
    <p><strong>Suppression TOTALE et IMM√âDIATE de tous Service Workers</strong></p>
    
    <div id="status" class="status">
        üîÑ Initialisation du nettoyage d'urgence...<br>
    </div>
    
    <button class="btn" onclick="emergencyCleanup()">
        üí• NETTOYAGE TOTAL IMM√âDIAT
    </button>
    
    <button class="btn btn-danger" onclick="nuclearOption()">
        ‚ò¢Ô∏è OPTION NUCL√âAIRE (Tout supprimer)
    </button>
    
    <button class="btn" onclick="checkStatus()">
        üîç V√©rifier Statut
    </button>

    <script>
        const status = document.getElementById('status');
        
        function log(message) {
            const time = new Date().toLocaleTimeString();
            status.innerHTML += `[${time}] ${message}<br>`;
            status.scrollTop = status.scrollHeight;
            console.log(message);
        }
        
        async function emergencyCleanup() {
            log('üö® D√âMARRAGE NETTOYAGE D\'URGENCE');
            
            try {
                // 1. Suppression de TOUS les Service Workers
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    log(`üîç ${registrations.length} Service Workers trouv√©s`);
                    
                    for (const registration of registrations) {
                        log(`üí• Suppression: ${registration.scope}`);
                        await registration.unregister();
                        log(`‚úÖ SW supprim√©: ${registration.scope}`);
                    }
                    
                    log('üéØ Tous les Service Workers supprim√©s');
                } else {
                    log('‚ö†Ô∏è Service Workers non support√©s');
                }
                
                // 2. Nettoyage de TOUS les caches
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    log(`üßπ ${cacheNames.length} caches trouv√©s`);
                    
                    for (const name of cacheNames) {
                        await caches.delete(name);
                        log(`üóëÔ∏è Cache supprim√©: ${name}`);
                    }
                    
                    log('‚ú® Tous les caches supprim√©s');
                }
                
                // 3. Nettoyage Storage
                localStorage.clear();
                sessionStorage.clear();
                log('üßΩ Storage local et session vid√©s');
                
                // 4. V√©rification finale
                setTimeout(async () => {
                    const finalCheck = await navigator.serviceWorker.getRegistrations();
                    if (finalCheck.length === 0) {
                        log('üéâ SUCCESS ! Plus aucun Service Worker actif');
                        alert('‚úÖ NETTOYAGE R√âUSSI ! Plus de Service Workers actifs.');
                    } else {
                        log(`‚ùå √âCHEC ! ${finalCheck.length} SW encore pr√©sents`);
                        alert('‚ö†Ô∏è √âchec partiel. Utilisez l\'option nucl√©aire.');
                    }
                }, 1000);
                
            } catch (error) {
                log(`üí• ERREUR: ${error.message}`);
            }
        }
        
        async function nuclearOption() {
            log('‚ò¢Ô∏è OPTION NUCL√âAIRE ACTIV√âE');
            
            try {
                // Suppression ultra-agressive
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    log(`‚ò¢Ô∏è Destruction nucl√©aire de ${registrations.length} SW`);
                    
                    await Promise.all(registrations.map(async (registration) => {
                        // Force l'arr√™t imm√©diat
                        if (registration.active) {
                            registration.active.postMessage({ command: 'SELF_DESTRUCT' });
                        }
                        await registration.unregister();
                        log(`üíÄ SW d√©truit: ${registration.scope}`);
                    }));
                }
                
                // Nettoyage nucl√©aire des caches
                const cacheNames = await caches.keys();
                await Promise.all(cacheNames.map(name => caches.delete(name)));
                log(`‚ò¢Ô∏è ${cacheNames.length} caches vaporis√©s`);
                
                // Reset complet
                if (typeof indexedDB !== 'undefined') {
                    // Note: On ne peut pas vraiment vider IndexedDB facilement
                    log('‚ö†Ô∏è IndexedDB n√©cessite nettoyage manuel dans DevTools');
                }
                
                localStorage.clear();
                sessionStorage.clear();
                
                log('‚ò¢Ô∏è DESTRUCTION NUCL√âAIRE TERMIN√âE');
                alert('‚ò¢Ô∏è Option nucl√©aire ex√©cut√©e ! Red√©marrez le navigateur pour confirmer.');
                
            } catch (error) {
                log(`üí• ERREUR NUCL√âAIRE: ${error.message}`);
            }
        }
        
        async function checkStatus() {
            log('üîç V√âRIFICATION STATUS');
            
            try {
                const registrations = await navigator.serviceWorker.getRegistrations();
                const cacheNames = await caches.keys();
                
                log(`üìä Service Workers: ${registrations.length}`);
                log(`üìä Caches: ${cacheNames.length}`);
                log(`üìä LocalStorage keys: ${Object.keys(localStorage).length}`);
                log(`üìä SessionStorage keys: ${Object.keys(sessionStorage).length}`);
                
                if (registrations.length === 0) {
                    log('‚úÖ STATUS: Application PROPRE !');
                } else {
                    log('‚ùå STATUS: Service Workers encore pr√©sents');
                    registrations.forEach((reg, i) => {
                        log(`  SW ${i+1}: ${reg.scope}`);
                    });
                }
                
            } catch (error) {
                log(`üí• ERREUR STATUS: ${error.message}`);
            }
        }
        
        // Auto-check au chargement
        window.addEventListener('load', () => {
            setTimeout(checkStatus, 500);
        });
    </script>
</body>
</html>
